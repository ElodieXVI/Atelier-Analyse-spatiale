---
title: "03_Disc. Cartographie des discontinuités et lissages"
author: "R. Leconte"
date: "11/01/2022"
output: html_document
---
```{r pkg}
library(mapsf)
library(maptiles)
library(potential)
```


MOP : plus on est grand plus on va lisser les phénomènes et la forme d'où l'intérêt des carroyages qui sont de taille régulière et fine.
Disconstinuité spatiale : phénomène de rupture affectant des répartitions à la surface de la Terre dans le domaine physique ou humain. Matrice ente unités spatiales et on mesure la dissemblance entre les deux unités spatiales considérées. Puis matrice de voisinnage 
Pour les liaison potentielles : lissages ou potentiels : corrigent les valeurs des unités spatiales en fonction des unités des voisins. Permet de sortir des discontinuité pour souligner les grandes structures. Corriger des artifices liés au MOP. 



# 1. Cartographie des discontinuités
```{r disc}
# Auto-intersection des communes (avec buffer, en mètres) pour s'assurer que les objets sont bien juxtaposés afin d'être bien sûr que les communes se touchent.
com_borders  <- st_intersection(st_buffer(comsf_avignon, 10), st_buffer(comsf_avignon, 10)) 
# Transformation des géométries en 'MULTILINESTRING'
com_borders  <- st_cast(com_borders ,"MULTILINESTRING")
# Suppression des intersections entre un même polygone
com_borders  <- com_borders [com_borders$CODGEO != com_borders$CODGEO.1, ] 
# Construction d'un identifiant unique pour chaque frontière
com_borders$CODGEO1 <- com_borders$CODGEO
com_borders$CODGEO2 <- com_borders$CODGEO.1
com_borders$CODGEO <-  paste0(com_borders$CODGEO1, "_", com_borders$CODGEO2)
rownames(com_borders) <- com_borders$CODGEO
com_borders  <- com_borders [,c("CODGEO","CODGEO1","CODGEO2","geometry")]
plot(com_borders$geometry)
# Récupération de la variable d'intérêt, en supprimant la géométrie associée
vals <- st_set_geometry(x = comsf_avignon[, c("CODGEO","Q218")], 
                        value = NULL)
# Double jointure pour récupérer les valeurs des NUTS limitrophes
com_borders <- merge (x = com_borders, y = vals, by.x = "CODGEO1", by.y = "CODGEO", all.x = T)
com_borders <- merge (x = com_borders, y = vals, by.x = "CODGEO2", by.y = "CODGEO", all.x = T)
# calcul de la discontinuité relative
com_borders$disc <- com_borders$Q218.x / com_borders$Q218.y
# on ne conserve que les 5% des discontinuités les plus fortes
threshold <- 0.95
disc <- com_borders[com_borders$disc >= quantile(com_borders$disc,threshold),]
# cartographie
mf_map(comsf_avignon, col = "grey80", border = "grey90")
mf_map(x = disc,
       var = "disc",
       col = "blue",
       lwd = 2,
       add = TRUE)
```

Raffiner la carte

```{r cartopretty}
# sélection des labels à ploter
bot <- comsf_avignon %>% 
top_n(wt = Q218, -5)
top <- comsf_avignon %>% 
  top_n(wt = Q218, 5)
topbot <- bind_rows(top, bot)

# carte
mf_map(comsf_avignon, 
       var = "Q218", 
       type = "choro", 
       breaks = "q6",
       pal =  hcl.colors(6, "teal", rev = TRUE), 
       border = NA, 
       leg_title = "Revenu médian\n(discrétisation Q6)")
mf_map(x = disc,
       col = "red",
       lwd = 3,
       add = TRUE)
mf_label( topbot, 
          var = "nom",
          cex = 0.5,
          col = "black",
          overlap = FALSE,
          lines = TRUE,
          halo=FALSE)
mf_layout(title = "Les discontinuités sociales les plus fortes dans l'unité urbaine de Paris (2018)",
    credits = "Auteur: R. Leconte, 2022. Données: INSEE, Filosofi, 2018",
    arrow = FALSE)
 mf_theme("default")
```


```{r disc}
# Auto-intersection des communes (avec buffer, en mètres) pour s'assurer que les objets sont bien juxtaposés afin d'être bien sûr que les communes se touchent.
com_borders  <- st_intersection(st_buffer(comsf_avignon, 10), st_buffer(comsf_avignon, 10)) 
# Transformation des géométries en 'MULTILINESTRING'
com_borders  <- st_cast(com_borders ,"MULTILINESTRING")
# Suppression des intersections entre un même polygone
com_borders  <- com_borders [com_borders$CODGEO != com_borders$CODGEO.1, ] 
# Construction d'un identifiant unique pour chaque frontière
com_borders$CODGEO1 <- com_borders$CODGEO
com_borders$CODGEO2 <- com_borders$CODGEO.1
com_borders$CODGEO <-  paste0(com_borders$CODGEO1, "_", com_borders$CODGEO2)
rownames(com_borders) <- com_borders$CODGEO
com_borders  <- com_borders [,c("CODGEO","CODGEO1","CODGEO2","geometry")]
plot(com_borders$geometry)
# Récupération de la variable d'intéret, en supprimant la géométrie associée
vals <- st_set_geometry(x = comsf_avignon[, c("CODGEO","TMY5Q218")], 
                        value = NULL)
# Double jointure pour récupérer les valeurs des NUTS limitrophes
com_borders <- merge (x = com_borders, y = vals, by.x = "CODGEO1", by.y = "CODGEO", all.x = T)
com_borders <- merge (x = com_borders, y = vals, by.x = "CODGEO2", by.y = "CODGEO", all.x = T)
# calcul de la discontinuité relative
com_borders$disc <- com_borders$TMY5Q218.x / com_borders$TMY5Q218.y
# on ne conserve que les 5% des discontinuités les plus fortes
threshold <- 0.95
disc <- com_borders[com_borders$disc >= quantile(com_borders$disc,threshold),]
# cartographie
mf_map(comsf_avignon, col = "grey80", border = "grey90")
mf_map(x = disc,
       var = "disc",
       col = "blue",
       lwd = 2,
       add = TRUE)
```



Option cartographique avec tuile

```{r}
# charger des tuiles
avignon_osm <- get_tiles(comsf_avignon, provider = "OpenStreetMap", crop = TRUE)
avignon_img <- get_tiles(comsf_avignon, provider = "Esri.WorldImagery", crop = TRUE)
avignon_db <- get_tiles(comsf_avignon, provider = "CartoDB.PositronNoLabels", crop = TRUE)
# voir la tuile
plot_tiles(avignon_db)
# créer le contour de notre aire d'étude
contour <- st_union(comsf_avignon)
# l'ajouter en fond de carte
mf_raster(avignon_osm)
mf_map(x = disc,
       col = "red",
       lwd = 3,
       add = TRUE)
mf_map(contour, col = NA, add = TRUE)
```


# 2. Cartes lissées


```{r pot}
# création d'une grille de points régulière pour lesquels seront calculées les valeurs de la variable
y <- create_grid(x = comsf_avignon, res = 5000)
# création d'une matrice de distance entre les points d'origine (centroides des communes), et les points de la grille
d <- create_matrix(x = comsf_avignon, y = y)
# calcul du potentiel
# fun = exponentielle
# span = distance à laquelle la valeur vaut 50% de celle du point d'origine
# beta = exposant de la distance 
y$pot <- potential(x = comsf_avignon, y = y, d = d,
                   var = "Q218", fun = "e",
                   span = 3000, beta = 2)
# calcul de l'équipotentiel : transformation des points en zones
iso <- equipotential(x = y, var = "pot", breaks = seq(min(y$pot),max(y$pot), 500), mask = comsf_avignon)
mf_map(x = iso, var = "center", type = "choro", 
       breaks = "equal", 
       nbreaks = 6,
       pal = hcl.colors(6, "teal", rev = TRUE),
       lwd = .2,
       border = NA, 
       leg_pos = "topleft",
       leg_val_rnd = 0,
       leg_title = "Potentiel de revenu\n(portée = 3km, exposant = 2) ")
mf_map(contour, col = NA, add=TRUE)
mf_label( topbot, 
          var = "nom",
          cex = 0.5,
          col = "black",
          overlap = FALSE,
          lines = FALSE,
          halo=FALSE)
mf_layout(title = "Le potentiel de revenu dans l'unité urbaine de Avignon (2018)",
    credits = "Auteur: R. Leconte, 2022. Données: INSEE, Filosofi, 2018",
    arrow = FALSE)
```